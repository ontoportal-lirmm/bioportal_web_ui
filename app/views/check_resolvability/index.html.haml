.search-page-container
  .search-page-subcontainer{'data-controller': 'reveal-component'}
    = form_tag(check_resolvability_path, method: :get, 'data-turbo': true) do
      .search-page-input-container{'data-controller': 'reveal'}
        .search-page-input
          %input{type:"url", placeholder:'Type a URI to test its resolvability', name: "url", value: @url}
          %button.search-page-button{type:'submit'}
            = inline_svg_tag 'icons/search.svg'

      = render(Layout::RevealComponent.new(toggle: true, selected: false)) do |c|
        - c.button do
          .d-flex.justify-content-end
            .search-page-advanced-button.show-options
              .icon
                = inline_svg_tag 'icons/settings.svg'
              .text
                Show help

        - c.container do
          %div.mt-2.mx-auto
            = render Display::AlertComponent.new(type:'info') do
              %h4 How it works
              %p
                The check resolvability tool allows you to test if a given URL is resolvable. It is based on the HTTP HEAD method.
                We check the resolvability of a URL by sending a HEAD request to the URL and checking if the response status code is 200 (OK) and
                the returned content type is equal to one of the following #{resolvability_formats.join(', ')}.
              %p
                We have a timeout set to #{resolvability_timeout} seconds, so if the URL is not resolvable within that time, the check will fail.
                And a max redirections set to #{resolvability_max_redirections}, so if the URL is not resolvable within that number of redirections, the check will fail.
            = render Display::AlertComponent.new(type:'info') do
              %h4
                Resolving a URI
              %p
                In the context of web semantics, dereferencing refers to the process of resolving and obtaining the actual data associated with a Uniform Resource Identifier (URI). In simpler terms, it involves following a link represented by a URI/IRI to retrieve information or resources linked to that identifier.
                In the Semantic Web, URIs are used to uniquely identify resources, and dereferencing allows systems to access and retrieve data related to those resources. When a URI/IRI is dereferenced, it typically leads to the retrieval of RDF (Resource Description Framework) data or other structured information that describes the resource in a machine-readable format. This enables systems to understand and process the meaning of the linked data, facilitating the exchange and integration of information on the web.

              %h4
                Content negotiation
              %p
                Content negotiation in the context of the Semantic Web refers to the mechanism by which two communicating parties, such as a client and a server, agree on the most suitable representation of a resource during the process of dereferencing a URI or IRI. This negotiation aims to ensure effective communication between different systems that may prefer different data formats or languages.
                In other words, when a client requests a resource by dereferencing a URI, it indicates its preferences for the format or language of the response data through HTTP headers or other negotiation mechanisms. The server, in turn, examines these preferences and selects the most appropriate representation of the resource based on what is available.
                different formats can be agreed upon between a client and server when accessing linked data. Common formats include:

                RDF/XML: XML-based representation of Resource Description Framework data.
                Turtle: Human-readable serialization format for RDF.
                JSON-LD: JSON-based format for linked data.
                N-Triples and N-Quads: Text formats for expressing RDF triples and quads.
                HTML: Markup language for web pages, also used to embed RDF data.
                RDFa: Embedding RDF data in HTML or XML using attributes.
                SPARQL Query Results XML and JSON: Formats for representing SPARQL query results.

    - if @results
      %div.bg-white.mt-3.border.rounded
        %div.p-1
          - text = check_resolvability_message(url_resolvable?(@results), @results[:allowed_format], @results[:status])
          - if url_content_negotiable?(@results)
            = render Display::AlertComponent.new(type:'success') do
              = text
          - elsif url_resolvable?(@results)
            = render Display::AlertComponent.new(type:'warning') do
              = text
          - else
            = render Display::AlertComponent.new(type:'danger') do
              = text
        %div.mt-2
          = render TableComponent.new(stripped: true) do |t|
            - t.add_row({th: 'Redirection path'})
            - @results[:redirections].each_with_index  do |r, index|
              - t.row do |row|
                - row.td do
                  = link_to r.to_s, r.to_s
                  - if !index.eql?(@results[:redirections].length - 1)
                    - color = 'text-warning bg-warning-light'
                    - status = '302'
                  - else
                    - status = @results[:status]
                    - color = status.eql?('200') ? '' : 'bg-danger-light text-danger'

                  - returned_format = !index.eql?(@results[:redirections].length - 1) ? nil : @results[:returned_formats]
                  = render ChipButtonComponent.new(class: "mx-1 #{color}", type: 'clickable', text: status)
                  - Array(returned_format).uniq.each do |format|
                    = render ChipButtonComponent.new(class: "mx-1", text: format.blank? ? 'Format not specified': format)







